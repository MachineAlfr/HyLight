import numpy as np
from scipy.integrate import simps
from scipy.interpolate import InterpolatedUnivariateSpline as interp
import serial,sys,glob

maryrgb = {'Ab':(247,75,39), 'A':(255,130,155), 'Bb':(254,123,13), 'B':(254,183,108), 'C':(255,213,0), 'Db':(255,253,175), 'D':(132,255,182), 'Eb':(1,50,252), 'E':(168,227,255), 'F':(225,160,255), 'Gb':(224,215,255), 'G':(60,186,45), 'A#':(254,183,108), 'C#':(255,253,175), 'D#':(1,50,252), 'F#':(225,160,255), 'G#':(247,75,39)} #Mary's note-RGB value synesthesia. 
ledhues = np.array([310.7591383551636,256.9803013093145,166.34978775550982,139.8502577003946,111.97934945232399,68.0252777377368,50.80611051592259,45.39216459850199,42.398437976796835],dtype=np.float) # The CIE LCh hue angle of the LEDs in the HyLight
ledxyzs = np.array([[401.18038167,100.45272655,2325.33593184],[268.12057298,349.16061572,1952.2485356],[90.29998114,739.69145295,271.60012609],[254.91036914,815.20037745,36.91546091],[631.16507486,924.57265065,45.36602422],[128.983218,92.2200947,0.0136668813],[548.498231,267.216229,.00517271580],[97.2855913,44.2955072,0.000409439786],[159.322201,65.5637038,0.000118704440]],dtype=np.float) # The XYZ values of the LEDs of the HyLight
cmf2 = np.genfromtxt('cie2006_2deg_xyz_cmf.dat',dtype=np.float,names='lam,x,y,z') # CIE 2006 2-degree color matching functions
cmf10 = np.genfromtxt('cie2006_10deg_xyz_cmf.dat',dtype=np.float,names='lam,x,y,z') # CIE 2006 10-degree color matching functions
cmf2x,cmf2y,cmf2z = interp(cmf2['lam'],cmf2['x'],ext=1),interp(cmf2['lam'],cmf2['y'],ext=1),interp(cmf2['lam'],cmf2['z'],ext=1) # Spline-interpolating the 2-deg CMFs, no extrapolating
cmf10x,cmf10y,cmf10z = interp(cmf10['lam'],cmf10['x'],ext=1),interp(cmf10['lam'],cmf10['y'],ext=1),interp(cmf10['lam'],cmf10['z'],ext=1) # Spline-interpolating the 2-deg CMFs, no extrapolating

XYZ2RGB = np.array([[0.4124564,0.3575761,0.1804375],[0.2126729,0.7151522,0.0721750],[0.0193339,0.1191920,0.9503041]]) # XYZ to sRGB transformation matrix
d65dty = np.array([0.135374307,3.11064022e-6,0.0905125250,0.0458485599,0.141045301,0.211474407,0.168065996,0.155121297,0.0525544959])*0.035*4096 #Percent duty cycles normalized to sum of scales that minimize RMS from CIE D65 reference spectrum, no IR
d65XYZ = np.array([43885.14629379,46314.2446249,49814.02187733],dtype=np.float) # XYZ values generated by the HyLight board for it's best D65 reference spectrum
idxcor = [0,8,7,6,5,4,3,1,2] # Correct order of the HyLight LEDs on the receiver Arduinos relative to the order of the LED data in this module
ard = serial.Serial() # Setting up Arduino PySerial object for later use
ard.baudrate = 9600 # Setting the baud rate needed for the serial communication

class Error(Exception):
	'''Base for Exceptions'''
	pass
	
class ValError(ValueError):
	'''Base for ValueErrors'''
	pass
	
class DangerPWM(ValError):
	'''Raised when PWM value is too large, which may damage they LED board!'''
	pass
	
class MissingVals(Error):
	'''Raised when the list of PWMs to be transmitted does not contain 10 elements'''
	pass
	
class NoCMF(ValError):
	'''Raised when the CMF viewing angle does not equal 2 or 10'''
	pass
	
class NoSerial(Error):
	'''Raised when the CMF viewing angle does not equal 2 or 10'''
	pass
	
def listports():
	'''Lists serial port names

		Raises EnvironmentError:
			On unsupported or unknown platforms
		Returns:
			result: list
				A list of the serial ports available on the system
	'''
	if sys.platform.startswith('win'):
		ports = ['COM%s' % (i + 1) for i in range(256)]
	elif sys.platform.startswith('linux') or sys.platform.startswith('cygwin'):
		ports = glob.glob('/dev/tty[A-Za-z]*')
	elif sys.platform.startswith('darwin'):
		ports = glob.glob('/dev/tty.*')
	else:
		raise EnvironmentError('Unsupported platform')
	result = []
	for port in ports:
		try:
			s = serial.Serial(port)
			s.close()
			result.append(port)
		except (OSError, serial.SerialException):
			pass
	return result

	
def numtonote(num):
	'''
	Maps midi numbers to their respective note name.
	
	Args:
		num: int
			The midi note number to be named
	
	Returns:
		notename: string
			The note name of the input midi note number
	'''
	freq = 2.**((num-69.)/12.)*440.
	A4 = 440.
	C0 = A4*np.power(2., -4.75)
	h = np.round(12.*np.log2(freq/C0),decimals=0).astype(int)
	n = h % 12
	return ['C','Db','D','Eb','E','F','Gb','G','Ab','A','Bb','B'][int(n)]


def labf(t):
	'''
	Function used to calulate the Lightness in the L*a*b* color space from
	the relative luminance of XYZ values to reference white, in this case D65. 
	
	Args:
		t: float
			The relative luminance of an X, Y, or Z value

	Returns:
		output: float
			The functional output used for calculating L*a*b* values from the
			XYZ relative luminance values
	'''
	if t>216./24389.:
		return t**(1./3.)
	return ((24389./27.)*t+16.)/116.

def xyz2lab(xyz):
	'''
	Converts tristimulus XYZ values into CIE L*a*b* color space values.
	
	Args:
		xyz: array_like
			The XYZ value to be converted into L*a*b* values.

	Returns:
		lab: ndarray
			The CIE L*a*b* values calculated from the input XYZ values.	
	'''
	if np.sum(xyz)<3.04:
		xyz = xyz*100.
	fx = labf(xyz[0]/94.811)
	fy = labf(xyz[1]/100.)
	fz = labf(xyz[2]/107.304)
	l = 116.*fy -16.
	a = 500.*(fx-fy)
	b = 200.*(fy-fz)
	return np.array([l,a,b])

def lab2lch(lab):
	'''
	Converts CIE L*a*b* color space values to CIE LCh color space values
	
	Args:
		lab: array_like
			The CIE L*a*b* value to be converted into CIE LCh values.

	Returns:
		lch: ndarray
			The LCh values calculated from the input L*a*b* values.	
	'''
	l = lab[0]
	c = np.sqrt(lab[1]**2+lab[2]**2)
	h = np.arctan2(lab[2],lab[1])*180./np.pi
	if h<0:
		h+=360.
	return np.array([l,c,h])


def calxyz(wave,inten,cmfdeg=10,norm=False):
	'''
	Calculates the tristimulus XYZ values of an input spectrum using the
	CIE 2006 2 or 10-degree "spline-interpolated" color matching functions. 
	
	Args:
		wave: array_like
			The wavelength data of the spectrum in nanometer units
		inten: array_like
			The intensity of the spectrum per wavelength bin. Can be
			arbitrary spectral radiance units, e.g., W/sr/m**2/nm
		cmfdeg: int
			The viewing angle of the CIE 2006 color matching functions.
			The argument must either be equal to either 2 or 10
		norm: bool
			If True, XYZ will be normalized to the sum of the three
			values. XYZ will not be normalized if False. 
	
	Returns:
		xyz: ndarray
			The XYZ values calculated from the input spectral data.	
	'''
	if cmfdeg==2:
		 cmfx,cmfy,cmfz=cmf2x,cmf2y,cmf2z
	elif cmfdeg==10:
		cmfx,cmfy,cmfz=cmf10x,cmf10y,cmf10z
	else:
		raise NoCMF('The requested CIE color matching function viewing angle does not exist: '+str(cmfdeg))
	X = simps(cmfx(wave)*inten,x=wave)
	Y = simps(cmfy(wave)*inten,x=wave)
	Z = simps(cmfz(wave)*inten,x=wave)
	if np.sum([X,Y,Z])!=0:
		if norm:
			return np.array([X,Y,Z])/np.sum([X,Y,Z])
		return np.array([X,Y,Z])
	return np.array([0,0,0])

def xyz2rgb(xyz):
	'''
	Converts XYZ values to sRGB values using the CIE D65 standard 
	illuminant as reference white.
	
	Args:
		xyz: array_like
			The XYZ value to be converted into sRGB values.

	Returns:
		rgb: ndarray
			The sRGB values calculated from the input XYZ values.	
	'''
	xyz = np.asarray(xyz,dtype=np.float)
	rgb = np.matmul(np.linalg.inv(XYZ2RGB),xyz)
	idx=0
	while idx<3:
		if rgb[idx] <= 0.0031308:
			rgb[idx] *= 12.92
		else:
			rgb[idx] = 1.055*rgb[idx]**(1./2.4)-0.055
		idx+=1
	return rgb

def rgb2xyz(rgb):
	'''
	Converts RGB values to tristimulus XYZ values using the CIE D65 standard 
	illuminant as reference white, assuming the RGB values are sRGB.
	
	Args:
		rgb: array_like
			The RGB value to be converted into XYZ values.

	Returns:
		xyz: ndarray
			The XYZ values calculated from the input RGB values.	
	'''
	rgb = np.asarray(rgb,dtype=float)
	idx=0
	while idx<3:
		if rgb[idx] > 1.0:
			rgb[idx] /= 255.
		if rgb[idx] <= .04045:
			rgb[idx] /= 12.92
		else:
			rgb[idx] = ((rgb[idx]+.055)/1.055)**2.4
		idx+=1
	xyz = np.matmul(XYZ2RGB,rgb)
	return xyz

def calhue(rgb):
	'''
	Calculates the hue of the RGB value in HSV/HSL color space.
	
	Args:
		rgb: array_like
			The RGB value to be used to determine a hue.

	Returns:
		hue: float
			The hue of the RGB value in the HSV/HSL color space.	
	'''
	rgb = np.asarray(rgb,dtype=float)
	idx=0
	while idx<3:
		if rgb[idx] > 1.0:
			rgb[idx] /= 255.
		idx+=1
	rgbmax = np.argmax(rgb)
	rgbrange = np.amax(rgb)-np.amin(rgb)
	if rgbmax==0:
		hue = 60*(0+(rgb[1]-rgb[2])/rgbrange)
	elif rgbmax==1:
		hue = 60*(2+(rgb[2]-rgb[0])/rgbrange)
	elif rgbmax==2:
		hue = 60*(4+(rgb[0]-rgb[1])/rgbrange)
	elif (r==g==b) or (np.amax(rgb)==np.amin(rgb)):
		hue = 0
	if hue<0:
		hue+=360
	return hue

def rgb2hsv(rgb):
	'''
	Converts RGB values to HSV values.
	
	Args:
		rgb: array_like
			The RGB value to be converted into HSV values.

	Returns:
		hsl: ndarray
			The HSV values calculated from the input RGB values.	
	'''
	rgb = np.asarray(rgb,dtype=float)
	idx=0
	while idx<3:
		if rgb[idx] > 1.0:
			rgb[idx] /= 255.
		idx+=1
	h = calhue(rgb)
	rgbmax,rgbmin = np.amax(rgb),np.amin(rgb)
	if (r==g==b==0) or (rgbmax==0):
		s=0
	else:
		s = (rgbmax-rgbmin)/rgbmax
	return np.array([h,s,rgbmax])

def rgb2hsl(rgb):
	'''
	Converts RGB values to HSL values.
	
	Args:
		rgb: array_like
			The RGB value to be converted into HSV values.

	Returns:
		hsl: ndarray
			The HSL values calculated from the input RGB values.	
	'''
	rgb = np.asarray(rgb,dtype=float)
	idx=0
	while idx<3:
		if rgb[idx] > 1.0:
			rgb[idx] /= 255.
		idx+=1
	h = calhue(r,g,b)
	rgbmax,rgbmin = np.amax(rgb),np.amin(rgb)
	if ((r==g==b==0) or (rgbmax==0)) or ((r==g==b==1) or (rgbmin==1)):
		s=0
	else:
		s=(rgbmax-rgbmin)/(1-np.abs(rgbmax+rgbmin-1))
	return np.array([h,s,(rgbmax+rgbmin)/2])

def hylrgb(rgb):
	'''
	Converts RGB values to PWM values to be sent to the HyLight board.
	
	Args:
		rgb: array_like
			The RGB value to be converted into PWM values

	Returns:
		pwm: ndarray
			The PWM values to be sent to the HyLight board.
	'''
	rgb = np.asarray(rgb,dtype=float) # Ensure the rgb array is a numpy array of floats
	XYZ = rgb2xyz(rgb)*d65XYZ[1] # Transforming rgb values into CIE XYZ values, and scaling to match d65 brightness
	hue = lab2lch(xyz2lab(rgb2xyz(rgb)))[2] # Calculating the hue angle of the input RGB value
	led1 = np.argmin(np.abs(hue-ledhues)) # Determining the LED with the closest hue to define a gamut
	if hue<ledhues[led1]: # Finding the 2nd closest LED to define a color-triangle gamut
		if hue<ledhues[8]:
			led2 = 0
		else:
			led2=np.argmin(np.abs(ledhues-np.amax(ledhues[(ledhues<hue) & (ledhues!=ledhues[led1])])))
	else:
		if hue>ledhues[0]:
			led2 = 8
		else:
			led2=np.argmin(np.abs(ledhues-np.amin(ledhues[(ledhues>hue) & (ledhues!=ledhues[led1])])))
	led1xyz,led2xyz = ledxyzs[led1],ledxyzs[led2] # Getting the XYZ values that define the gamut, keeping the HyLight D65 constant as the 3rd point of the triangle
	M = np.array([[ledxyzs[led2][0],ledxyzs[led1][0],d65XYZ[0]],[ledxyzs[led2][1],ledxyzs[led1][1],d65XYZ[1]],[ledxyzs[led2][2],ledxyzs[led1][2],d65XYZ[2]]]) # Generate the transformation matrix for converting the RGB values to the 10 LED duty-cycles
	vpwm = np.matmul(np.linalg.inv(M),XYZ) # Calculate the PWMs for the virtual LEDs using the matrix transformation
	pwm = vpwm[2]*d65dty # Calculate actual LED PWMs from the virtual LED PWMs
	pwm[led2] += vpwm[0]
	pwm[led1] += vpwm[1]
	pwm[pwm<0]=0 # Set negative PWM values to 0
	pwm = np.append(pwm,0) # Not using IR LED
	return pwm.astype(int) # Return integers
	
def send(addr,pwms,power=1.,autoscale=True):
	'''
	Sends an array of PWM values to a designated receiver. The PWM values
	can be scaled using the power argument. 
	
	Args:
		addr: int
			The address of the receiver to be transmitted to. A value of 0
			will transmit to "SciHub HyLighter Receiver #01", a value of 1
			will transmit to "SciHub HyLighter Receiver #02", and so on ...
		pwms: array_like
			An array of 10 PWM values to be transmitted to the designated
			receiver. The 10 PWM values will be set on the HyLight board
			connected to the receiver. 
		power: float
			A scale factor for the PWM values for scaling the brightness of
			all LEDs uniformly by the same constant.	
		autoscale: bool
			If True, the PWM values will be automatically scaled to the brightest
			safe duty cycle to operate at, otherwise a ValueError will occur if 
			the PWM values are beyond 10% of the max duty-cycle. 

	Returns:
		None
	'''
	pwms=np.array(pwms,dtype=np.float)*power # Scale the pwm values by constant value defined by the 'power' variable
	if not (ard.isOpen()):
		errmsg = "Please set ard.port to the path of your transmitter arduino port\ne.g., ard.port='/dev/tty.usbmodem1' then call ard.open(). Perhaps one of the following:\n"+str(listports())
		raise NoSerial(errmsg)
	if autoscale and np.any(pwms>4096.*.1): # Autoscale the led pwm values to a safe value to not damage the HyLighter boards
		pwms = pwms*(4096.*.1/np.amax(pwms))
	if np.any(pwms>4096.*.101): # Check if any LEDs are too bright for the HyLighter board
		raise DangerPWM('PWM value is too large, may damage they LED board: '+str(pwms[np.argwhere(pwms>4096.*.101)]))
	if pwms.size!=10: # Check if all the LEDs are being addressed. If not, raise an excepction.
		raise MissingVals('List of PWMs to be sent must contain exactly 10 elements')
	pwms = (pwms[idxcor]).astype(int) # Reorder the PWM values in the correct order so the ArNRF PCB sends the value to the correct LEDs
	command = str(addr)+' ' # Initializig the string to be transmitted to a receiver
	for pwm in pwms:
		command+=str(pwm)+' '  # Appending the all PWM values to the string to be transmitted
	command += '0'
	ard.write(command.encode()) # Sending the command to the transmitter for transmission 

'''#This short for-loop shows how one could cycle through Mary's synesthesia using the HyLight board
for note in ['C','Db','D','Eb','E','F','Gb','G','Ab','A','Bb','B']:
	send(0,hylrgb(maryrgb[note]),power=10)
	time.sleep(1.)
'''
